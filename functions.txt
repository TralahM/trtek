	abbrev    ;; (short long)   
	abbrevs    ;; (&rest names)   
	achieve-all    ;; (state goals goal-stack)  
	achieve    ;; (state goal goal-stack)  
	acos-deg    ;; (x)    
	after    ;; (x y lst &key (test
	alrec    ;; (rec &optional base)  
	append1    ;; (lst obj)   
	apply-op    ;; (state goal op goal-stack) 
	appropriate-p    ;; (goal op)   
	approx-equal    ;; (x y &optional (*epsilon* *epsilon*))
	asin-deg    ;; (x)    
	atan-deg    ;; (x)    
	avg    ;; (&rest args)   
	*banana-ops*    ;;     
	before    ;; (x y lst &key (test
	best    ;; (fn lst)   
	break-loop    ;; (fn quit &rest args) 
	build-call    ;; (op fns)   
	build-compose    ;; (fns)    
	chars    ;; (str)    
	chars    ;; (str) (loop for c across
	choose    ;; (n r)   
	cmplmnt    ;; (fn)    
	compile-net    ;; (root)    
	compose    ;; (&rest fns)   
	conc1    ;; (lst obj)   
	convert-op    ;; (op)    
	cos-deg    ;; (angle)    
	cross-product    ;; (xlist ylist &optional (fn #'list))
	cumsum    ;; (lst &key (smsf 0)) 
	dbg    ;; (id format-string &rest args) 
	*dbg-ids*    ;; nil "Identifiers used by dbg")
	dbg-indent    ;; (id indent format-string &rest args)
	defnode    ;; (&rest args)   
	deg-to-rad    ;; (deg)    
	differences    ;; (set &rest outs)  
	dot-product    ;; (&rest vectors)   
	duplicate    ;; (obj lst &key (test #'eql))
	*epsilon*    ;; 1.0e-6)    
	executing-p    ;; (x)    
	explode    ;; (sym)    
	fact    ;; (x)    
	fif    ;; (if then &optional else) 
	filter    ;; (fn lst)   
	find2    ;; (fn lst)   
	find-all    ;; (item sequence &rest keyword-args 
	fint    ;; (fn &rest fns)  
	flatten    ;; (x)    
	fn    ;; (expr) `#',(rbuild expr))  
	fun    ;; (fn &rest fns)  
	gdebug    ;; (&rest ids)   
	GPS    ;; (state goals &optional (*ops* *ops*))
	group    ;; (source n)   
	intersections    ;; (&rest sets)   
	last1    ;; (lst)    
	longer    ;; (x y)   
	lrec    ;; (rec &optional base)  
	map0-n    ;; (fn n)   
	map1-n    ;; (fn n)   
	mapa-b    ;; (fn a b &optional (step
	mapcars    ;; (fn &rest lsts)  
	map->    ;; (fn start test-fn succ-fn) 
	mappend    ;; (fn &rest lsts)  
	maxmin    ;; (args)    
	member-equal    ;; (item list)   
	memoize    ;; (fn)    
	mklist    ;; (obj)    
	mkstr    ;; (&rest args)   
	most    ;; (fn lst)   
	mostn    ;; (fn lst)   
	nif    ;; (expr pos zero neg) 
	nil!    ;; (var)    
	node    ;; contents yes no)  
	*nodes*    ;; nil)    
	on-cdrs    ;; (rec base &rest lsts) 
	op    ;; (action &key preconds add-list del-list)
	op    ;; "An operation"   
	*ops*    ;; nil "A list of available
	package-external-symbols    ;; (package)    
	package-internal-symbols    ;; (package)    
	prompt    ;; (&rest args)   
	propmacro    ;; (propname)    
	propmacros    ;; (&rest props)   
	prune    ;; (test tree)   
	rad-to-deg    ;; (rad)    
	rbuild    ;; (expr)    
	readlist    ;; (&rest args)   
	reread    ;; (&rest args)   
	rfind-if    ;; (fn tree)   
	rmapcar    ;; (fn &rest args)  
	*school-ops*    ;;     
	sigmoid    ;; (x)    
	sigmoid*    ;; (x)    
	sin-deg    ;; (angle)    
	single    ;; (lst)    
	split-if    ;; (fn lst)   
	starts-with    ;; (list x)   
	sumlist    ;; (lst)    
	symb    ;; (&rest args)   
	tan-deg    ;; (angle)    
	tek-copy-list    ;; (lst)    
	tek-every    ;; (fn lst)   
	tek-find-if    ;; (fn lst)   
	tek-remove-duplicates    ;; (lst)    
	tek-some    ;; (fn lst)   
	test-using    ;; (x val)   
	trec    ;; (rec &optional (base #'identity)) 
	trtek    ;;     
	ttrav    ;; (rec &optional (base #'identity)) 
	undebug    ;; (&rest ids )  
	unions    ;; (&rest sets)   
	use    ;; (oplist)    
	using    ;; (var form &body body) 
	while    ;; (test &body body)  
	zipdiff    ;; (&rest args)   
	zipdiv    ;; (&rest args)   
	zipmult    ;; (&rest args)   
	zipn    ;; (&rest args)   
	zipsum    ;; (&rest args)   
	zip    ;; (x y)   
